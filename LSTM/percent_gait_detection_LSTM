# In[] Start

from utils import sequence_data_generator as SeqDataGenerator
from utils import tensorflow_lstm_model as GaitLSTM
from tensorflow.python.client import device_lib
from sklearn.preprocessing import MinMaxScaler
import logging, os, time
import tensorflow as tf
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
os.environ["CUDA_VISIBLE_DEVICES"] = "0"


tf.get_logger().setLevel(logging.INFO)

DATA = ['Time', 'q', 'qdot',
        'pelv_gyro_x', 'pelv_gyro_y', 'pelv_gyro_z',
        'pelv_acc_x', 'pelv_acc_y', 'pelv_acc_z',
        'leg_gyro_x', 'leg_gyro_y', 'leg_gyro_z',
        'leg_acc_x', 'leg_acc_y', 'leg_acc_z']

FEATURE = ['pelv_gyro_x', 'pelv_gyro_y', 'pelv_gyro_z',
           'leg_gyro_x', 'leg_gyro_y', 'leg_gyro_z']

LABEL = ['Label']

csv_reader = pd.read_csv('datasets/walking_data.csv', encoding='utf-8')

# plt.title('Gait pattern segmentation')
# plt.xlabel('time')
# plt.grid()
# plt.xlim([0, 600])

# plt.plot(csv_reader['leg_gyro_z'])
# plt.plot(csv_reader['q'])
# plt.plot(csv_reader['Label']/100)

# plt.legend(('leg_gyro_z', 'q', 'Label'))
# plt.show()

# In[] Feature data

scaler = MinMaxScaler()
normalized_data = scaler.fit_transform(csv_reader[DATA])
normalized_data = pd.DataFrame(normalized_data, columns=DATA)

# plt.xlabel('time')
# plt.grid()
# plt.xlim([0, 600])

# plt.plot(normalized_data['leg_gyro_z'])
# plt.plot(normalized_data['q'])

# plt.legend(('leg_gyro_z', 'q'))
# plt.show()

# In[] Sequence dataset

feature = pd.DataFrame(normalized_data, columns=FEATURE).to_numpy().astype(float)
label = pd.DataFrame(csv_reader, columns=LABEL).to_numpy().astype(float)

feature, label = SeqDataGenerator.make_sequene_dataset(feature, label, 300)

X_train, Y_train, X_test, Y_test = SeqDataGenerator.make_train_and_test_dataset(feature, label, 0.1)

Y_train = tf.one_hot(Y_train, 100)
Y_train = np.reshape(Y_train, (Y_train.shape[0],Y_train.shape[2]))
Y_test = tf.one_hot(Y_test, 100)
Y_test = np.reshape(Y_test, (Y_test.shape[0],Y_test.shape[2]))

print(X_train.shape)
print(Y_train.shape)
print(X_test.shape)
print(Y_test.shape)

# In[] GPU Check

# print(tf.__version__)
# print(device_lib.list_local_devices())
print("Num GPUs Available: ", len(tf.config.list_physical_devices('GPU')))

# In[] Train

if tf.config.list_physical_devices("GPU"):
    strategy = tf.distribute.MirroredStrategy()  # set to MirroredStrategy
    print("Strategy is set to MirroredStrategy")
else:
    strategy = tf.distribute.get_strategy()  # set to the default strategy
    print("Strategy is set to DefaultDistributionStrategy")

with strategy.scope():
    model = GaitLSTM.initialize_lstm_model(X_train)
    model = GaitLSTM.compile_lstm_model(model)
    monitor = GaitLSTM.set_monitor_lstm_model()

    model.summary()
    # Fit the model
    time_start = time.localtime()
    print(f"Model startet at: {time_start.tm_hour}:{time_start.tm_min}:{time_start.tm_sec}")
    model_history = GaitLSTM.fit_lstm_model(model, X_train, Y_train, X_test, Y_test, monitor, 100)
    time_end = time.localtime()
    print(f"Model finished at: {time_start.tm_hour}:{time_start.tm_min}:{time_start.tm_sec}")


# In[] Graph

pred = model.predict(X_test)

print(X_test.size)
print(Y_test)
print(pred.size)

Y_test = np.argmax(Y_test, axis=1)
pred = np.argmax(pred, axis=1)

plt.figure(figsize=(12, 6))
plt.ylabel('label')
plt.xlabel('time')
plt.grid()
plt.legend(loc='best')
plt.xlim([0, 600])

plt.plot(Y_test, label='actual')
plt.plot(pred, label='prediction')

plt.show()

#In[] Accuracy

plt.plot(model_history.history['accuracy'])
plt.plot(model_history.history['val_accuracy'])
plt.title('Model accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Test'], loc='upper left')
plt.show()

#In[] Loss
plt.plot(model_history.history['loss'])
plt.plot(model_history.history['val_loss'])
plt.title('Model loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Train', 'Test'], loc='upper right')
plt.show()
# In[] End
